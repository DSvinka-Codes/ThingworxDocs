---
description: white/for, break, continue
---

# Циклы

## Цикл «while»

Цикл `while` имеет следующий синтаксис:

```javascript
while (condition) {
  // код
  // также называемый "телом цикла"
}
```

Код из тела цикла выполняется, пока условие `condition` истинно.

Например, цикл ниже выводит `i`, пока `i < 3`:

```javascript
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  me.exampleTable.AddRow({index: i})
  i++;
}
```

Одно выполнение тела цикла по-научному называется **"итерация"**. Цикл в примере выше совершает три итерации.

Если бы строка `i++` отсутствовала в примере выше, то цикл бы повторялся (в теории) вечно. На практике, конечно, Thingworx не позволит такому случиться, он просто убьёт процесс.

Любое выражение или переменная может быть условием цикла, а не только сравнение: условие `while` вычисляется и преобразуется в логическое значение.

Например, `while (i)` – более краткий вариант `while (i != 0)`:

```javascript
let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  me.exampleTable.AddRow({index: i})
  i--;
}
```

Фигурные скобки не требуются для тела цикла из одной строки

Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки `{…}`:

```javascript
let i = 3;
while (i) me.exampleTable.AddRow({index: i--});
```

## Цикл «do…while»

Проверку условия можно разместить под телом цикла, используя специальный синтаксис `do..while`:

```javascript
do {
  // тело цикла
} while (condition);
```

Цикл сначала выполнит тело, а затем проверит условие `condition`, и пока его значение равно `true`, он будет выполняться снова и снова.

Например:

```javascript
let i = 0;
do {
  me.exampleTable.AddRow({index: i})
  i++;
} while (i < 3);
```

Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось **хотя бы один раз**, даже если условие окажется ложным. На практике чаще используется форма с предусловием: `while(…) {…}`.

## Цикл «for»

Более сложный, но при этом самый распространённый цикл — цикл `for`.

Выглядит он так:

```javascript
for (начало; условие; шаг) {
  // ... тело цикла ...
}
```

Давайте разберёмся, что означает каждая часть, на примере. Цикл ниже выполняет `me.exampleTable.AddRow({index: i})` для `i` от `0` до (но не включая) `3`:

```javascript
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  me.exampleTable.AddRow({index: i});
}
```

Рассмотрим конструкцию `for` подробней:

| часть   |             |                                                                                                                          |
| ------- | ----------- | ------------------------------------------------------------------------------------------------------------------------ |
| начало  | `let i = 0` | Выполняется один раз при входе в цикл                                                                                    |
| условие | `i < 3`     | <p>Проверяется <em>перед</em> каждой итерацией цикла.<br>Если оно вычислится в <code>false</code>, цикл остановится.</p> |
| тело    | `alert(i)`  | Выполняется снова и снова, пока условие вычисляется в `true`.                                                            |
| шаг     | `i++`       | Выполняется _после_ тела цикла на каждой итерации _перед_ проверкой условия.                                             |

В целом, алгоритм работы цикла выглядит следующим образом:

```none
Выполнить начало
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ ...
```

То есть, `начало` выполняется один раз, а затем каждая итерация заключается в проверке `условия`, после которой выполняется `тело` и `шаг`.

Если тема циклов для вас нова, может быть полезным вернуться к примеру выше и воспроизвести его работу на листе бумаги, шаг за шагом.

Вот в точности то, что происходит в нашем случае:

```javascript
// for (let i = 0; i < 3; i++) me.exampleTable.AddRow({index: i})

// Выполнить начало
let i = 0;

// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { 
  me.exampleTable.AddRow({index: i}); 
  i++ 
}

// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { 
  me.exampleTable.AddRow({index: i}); 
  i++ 
}

// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) { 
  me.exampleTable.AddRow({index: i}); 
  i++ 
}

// ...конец, потому что теперь i == 3
```

Встроенное объявление переменной

В примере переменная счётчика `i` была объявлена прямо в цикле. Это так называемое «встроенное» объявление переменной. Такие переменные существуют только внутри цикла.

```javascript
for (let i = 0; i < 3; i++) {
  me.exampleTable.AddRow({index: i}); // 0, 1, 2
}

me.exampleTable.AddRow({index: i}); // ошибка, нет такой переменной
```

Вместо объявления новой переменной мы можем использовать уже существующую:

```javascript
let i = 0;

for (i = 0; i < 3; i++) { // используем существующую переменную
  me.exampleTable.AddRow({index: i}); // 0, 1, 2
}

me.exampleTable.AddRow({index: i}); 
// 3, переменная доступна, т.к. была объявлена снаружи цикла
```

## Пропуск частей «for»

Любая часть `for` может быть пропущена.

Для примера, мы можем пропустить `начало` если нам ничего не нужно делать перед стартом цикла.

Вот так:

```javascript
let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) { // нет необходимости в "начале"
  me.exampleTable.AddRow({index: i}); // 0, 1, 2
}
```

Можно убрать и `шаг`:

```javascript
let i = 0;

for (; i < 3;) {
  me.exampleTable.AddRow({index: i++});
}
```

Это сделает цикл аналогичным `while (i < 3)`.

А можно и вообще убрать всё, получив бесконечный цикл:

```javascript
for (;;) {
  // будет выполняться вечно
}
```

При этом сами точки с запятой `;` обязательно должны присутствовать, иначе будет ошибка синтаксиса.

## Прерывание цикла: "break"

Обычно цикл завершается при вычислении _условия_ в `false`.

Но мы можем выйти из цикла в любой момент с помощью специальной директивы `break`.

<pre class="language-javascript"><code class="lang-javascript"><strong>const steps = [
</strong><strong>  {x: 30, y: 30}, // &#x3C;-- Этот step пройдет нормально.
</strong>  {x: 20, y: 20}, // &#x3C;-- Этот step пройдет нормально.
  {x: 20, y: 70}, // &#x3C;-- После этого step, цикл ниже - остановится (y = 70)
  {x: 90, y: 30}, // &#x3C;-- А если убрать предыдущую строку, (x = 90)
                  // то после этой цикл - остановится
  {x: 80, y: 20}, // &#x3C;-- А если убрать предыдущую строку, (x = 80)
                  // то после этой цикл - остановится
  {x: 50, y: 20}, // &#x3C;-- А вот эта строка пройдет нормально 
                  // (x == 50, а не больше, было бы 51 то цикл бы прервался)
<strong>];
</strong><strong>
</strong><strong>// Функция перемещает робота на ступень. 
</strong><strong>// Если одна из координата превышает пороговое значение в 50 
</strong><strong>// то функция возвращает false 
</strong><strong>function GoToStep(step) {
</strong><strong>  if (step.x > 50 || step.y > 50) {
</strong><strong>    return false;
</strong><strong>  } else {
</strong><strong>    me.gripperX = step.x;
</strong><strong>    me.gripperY = step.y;
</strong><strong>    return true
</strong><strong>  }
</strong><strong>};
</strong>
me.runError = false;
me.runEnded = false;

for (let i = 0; i &#x3C; steps.length; i++) {  
  let step = steps[i];
  let result = GoToStep(step);

  // Если произошла ошибка, то меняем Property - runError 
  // и прерываем цикл  
  if (!result) {
    me.runError = true;
    break;
  }

  pause(2 * 1000);  // Ждём 2 секунду
}

me.runEnded = true;
</code></pre>

Директива `break` в строке полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на `me.runEnded = true;`

{% hint style="info" %}
Вообще, сочетание «бесконечный цикл + `break`» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела.

Но в Thingworx циклы весьма опасная вещь. \
И вам нужно тщательно тестировать код с циклами чтобы убедится что они не сломают вам код.

<mark style="color:yellow;">**Реальные и полезные примеры с циклами в Thingworx описаны в**</mark> [poleznye-primery.md](../code/poleznye-primery.md "mention")&#x20;
{% endhint %}

## Переход к следующей итерации: continue

Директива `continue` – «облегчённая версия» `break`. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно `true`).

Её используют, если понятно, что на текущем повторе цикла делать больше нечего.

Например, цикл ниже использует `continue`, чтобы выводить только нечётные значения:

```javascript
for (let i = 0; i < 10; i++) {

  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) 
    continue;

  me.exampleTable.AddRow({number: i});  // 1, затем 3, 5, 7, 9
}
```

Для чётных значений `i`, директива `continue` прекращает выполнение тела цикла и передаёт управление на следующую итерацию `for` (со следующим числом). Таким образом `AddRow`вызывается только для нечётных значений.

Директива `continue` позволяет избегать вложенности

Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:

```javascript
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    me.exampleTable.AddRow({number: i});
  }

}
```

С технической точки зрения он полностью идентичен. Действительно, вместо `continue` можно просто завернуть действия в блок `if`.

Однако мы получили дополнительный уровень вложенности фигурных скобок. Если код внутри `if` более длинный, то это ухудшает читаемость, в отличие от варианта с `continue`.

Нельзя использовать `break/continue` справа от оператора „?“

Обратите внимание, что эти синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором `?`. В частности, использование таких директив, как `break/continue`, вызовет ошибку.

Например, если мы возьмём этот код:

```javascript
if (i > 5) {
  me.exampleTable.AddRow({number: i});
} else {
  continue;
}
```

…и перепишем его, используя вопросительный знак:

```javascript
(i > 5) ? me.exampleTable.AddRow({index: i}); : continue; 
// continue здесь приведёт к ошибке
```

…то будет синтаксическая ошибка.

{% hint style="info" %}
Это ещё один повод не использовать оператор вопросительного знака `?` вместо `if`.
{% endhint %}
